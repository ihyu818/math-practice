<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>因式分解實驗室 - 專業版</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --fluid-text: clamp(1.2rem, 6vw, 2.8rem);
      --fluid-slot: clamp(2rem, 10vw, 4rem);
    }
    
    /* 基礎按鍵樣式 */
    .key-btn { 
      display: flex; align-items: center; justify-content: center; 
      background-color: white; border: 1px solid #e5e7eb; border-radius: 0.75rem; 
      font-weight: bold; font-size: clamp(1rem, 4vw, 1.5rem);
      height: 50px; transition: all 0.05s; cursor: pointer; user-select: none;
      -webkit-tap-highlight-color: transparent; 
    }
    .key-btn:active { background-color: #fdf2f8; transform: scale(0.95); }
    .key-btn-op { background-color: #fdf2f8; color: #db2777; border-color: #fbcfe8; }
    .key-btn-next { background-color: #10b981; color: white; border-color: #059669; }
    
    .slot { 
      border-bottom: 3px solid #d1d5db; min-width: var(--fluid-slot); 
      height: 50px; display: inline-flex; align-items: center; justify-content: center; 
      font-weight: 800; font-size: var(--fluid-text); transition: all 0.2s; 
    }
    .slot.active { border-color: #db2777; background-color: #fff1f2; }
    
    /* ----------------------------------------------------------- */
    /* 橫向模式專用樣式 (手機打橫時) */
    @media (orientation: landscape) and (max-height: 500px) {
      .game-container { display: flex; flex-direction: row; align-items: center; gap: 20px; padding: 10px !important; }
      .side-info { flex: 1; display: flex; flex-direction: column; justify-content: center; }
      .side-keyboard { flex: 1; max-width: 320px; }
      .slot { height: 40px; min-width: 45px; }
      .key-btn { height: 40px; font-size: 1.1rem; }
      .score-box { margin-bottom: 5px !important; padding: 5px !important; }
      .problem-box { height: auto !important; margin-bottom: 10px !important; }
    }
    /* ----------------------------------------------------------- */

    .correct-flash { animation: flash 0.3s ease-out; }
    @keyframes flash { 0% { background-color: transparent; } 50% { background-color: #d1fae5; } 100% { background-color: transparent; } }
    #timer-bar { transition: width 1s linear; }
  </style>
</head>
<body class="bg-gray-50 overflow-x-hidden text-slate-800 font-sans">
  <div id="app"></div>

  <script>
    const LEADERBOARD_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSsRbSkdS47TMRDMHkp9RDNevrhcapO29YCcn0e4ey4la1RxhEIyYfGcvFElqladVxKsNcoLJi2RHSk/pubhtml?gid=1870741910&single=true&range=G1:H11'; 
    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbz5SPY0XNjPWaRAgSmSZx1cSgTTeuACaT17Lx96Oy0TkALO0mgOKA-mr3KuUtFCNVir2Q/exec'; 
    const TOTAL_TIME = 120;

    let state = {
      mode: 'play', // 直接進入遊戲
      name: localStorage.getItem('math_lab_name') || 'Guest', 
      problem: null, 
      userInputs: ["", "", "", ""], currentSlot: 0, 
      isAnswerCorrect: false, score: 0, combo: 0, maxCombo: 0, timeLeft: TOTAL_TIME,
      hasUsedBack: false
    };

    let timer = null;

    function render() {
      const app = document.getElementById('app');
      if (state.mode === 'play' && !state.problem) return;
      if (state.mode === 'login') {
        state.mode = 'play';
        handleStart(); // 啟動遊戲邏輯
        return;
      }
      else if (state.mode === 'play') {
        const timePercent = (state.timeLeft / TOTAL_TIME) * 100;
        app.innerHTML = `
          <div class="min-h-screen p-3 flex flex-col items-center max-w-4xl mx-auto game-container ${state.isAnswerCorrect ? 'correct-flash' : ''}">
            <div class="side-info w-full">
              <div class="w-full bg-gray-200 h-2 rounded-full mb-3 overflow-hidden">
                <div id="timer-bar" class="bg-pink-500 h-full" style="width: ${timePercent}%"></div>
              </div>

              <div class="w-full grid grid-cols-3 bg-white p-3 rounded-2xl shadow-sm mb-4 items-center text-center score-box">
                <div class="text-left truncate text-[10px] text-slate-300 font-bold uppercase">${state.name}</div>
                <div><div class="text-[8px] text-slate-400 uppercase">Score</div><div class="text-xl text-pink-600 font-black">${state.score.toFixed(1)}</div></div>
                <div class="text-right"><div class="text-[8px] text-slate-400 uppercase">Combo</div><div class="text-xl font-black text-orange-500">${state.combo}</div></div>
              </div>

              <div class="text-center mb-4 h-16 flex items-center justify-center problem-box">
                <div class="font-black text-slate-800" style="font-size: var(--fluid-text)">${state.problem.display}</div>
              </div>

              <div class="mb-6 font-black flex items-center justify-center gap-1 text-slate-700 w-full" style="font-size: clamp(1rem, 5vw, 2rem)">
                <span class="text-slate-300">=</span>
                <span>( x </span>
                <div class="slot ${state.currentSlot===0?'active':''} text-pink-600">${state.userInputs[0]}</div>
                <div class="slot ${state.currentSlot===1?'active':''} text-pink-600">${state.userInputs[1]}</div>
                <span> ) ( x </span>
                <div class="slot ${state.currentSlot===2?'active':''} text-pink-600">${state.userInputs[2]}</div>
                <div class="slot ${state.currentSlot===3?'active':''} text-pink-600">${state.userInputs[3]}</div>
                <span> )</span>
              </div>
            </div>

            <div class="side-keyboard w-full flex flex-col gap-2">
              <div class="grid grid-cols-4 gap-2">
                <div class="col-span-3 grid grid-cols-3 gap-2">
                  ${[7,8,9,4,5,6,1,2,3].map(n => `<div onclick="pressKey('${n}')" class="key-btn shadow-sm">${n}</div>`).join('')}
                  <div onclick="pressKey('0')" class="key-btn shadow-sm">0</div>
                  <div onclick="pressKey('+')" class="key-btn key-btn-op shadow-sm">+</div>
                  <div onclick="pressKey('-')" class="key-btn key-btn-op shadow-sm">-</div>
                </div>
                <div class="col-span-1 flex flex-col">
                  <div onclick="pressKey('back')" class="key-btn bg-red-50 text-red-500 shadow-sm w-full h-full text-xl">⌫</div>
                </div>
              </div>
              <div onclick="pressKey('next')" class="key-btn key-btn-next shadow-lg text-lg italic uppercase font-black w-full">Next / →</div>
            </div>
          </div>`;
      }
      else if (state.mode === 'end') {
        app.innerHTML = `<div class="min-h-screen flex items-center justify-center p-4"><div class="bg-white p-8 rounded-3xl shadow-2xl w-full max-w-sm text-center border-b-8 border-pink-600">
          <h2 class="text-2xl font-black mb-4 text-slate-800 italic uppercase">Mission Success</h2>
          <div class="text-6xl font-black text-pink-600 mb-8">${state.score.toFixed(2)}</div>
          <button onclick="location.reload()" class="w-full bg-pink-600 text-white py-4 rounded-2xl font-black shadow-lg mb-4">Retry</button>
          <button onclick="location.href='index.html'" class="w-full text-slate-400 font-bold">Back to Menu</button>
        </div></div>`;
      }
    }

    function pressKey(key) {
      if (state.isAnswerCorrect) return;

      if (key === 'back') {
        state.hasUsedBack = true;
        if (state.userInputs[state.currentSlot] === "" && state.currentSlot > 0) state.currentSlot--;
        state.userInputs[state.currentSlot] = "";
      } 
      else if (key === 'next') {
        const currentVal = state.userInputs[state.currentSlot];
        
        // 只有在當前格子為空時，才判斷是否允許「自動補位」
        if (currentVal === "") {
          const targetA = state.problem.ansA;
          const targetB = state.problem.ansB;

          // 判斷當前格子對應的正確數值是否為 0
          let canSkip = false;
          if (state.currentSlot <= 1) { // 第一對括號 (x + 0)
            if (targetA === 0 || targetB === 0) canSkip = true;
          } else { // 第二對括號 (x + 0)
            if (targetA === 0 || targetB === 0) canSkip = true;
          }

          if (canSkip) {
            // 如果答案確實包含 0，才允許補位
            state.userInputs[state.currentSlot] = (state.currentSlot % 2 === 0) ? "+" : "0";
          } else {
            // 如果答案不是 0，按 Next 不准補位，直接跳過不處理
            return; 
          }
        }
        
        if (state.currentSlot < 3) {
          state.currentSlot++;
        } else {
          checkAnswer(true); 
        }
      }
      else {
        if (state.currentSlot % 2 === 0) { // 符號格
          if (key === '+' || key === '-') {
            if (state.userInputs[state.currentSlot] !== "" && state.userInputs[state.currentSlot] !== key) state.hasUsedBack = true;
            state.userInputs[state.currentSlot] = key;
            state.currentSlot++;
          }
        } else { // 數字格
          if (!isNaN(key)) {
            if (state.userInputs[state.currentSlot] !== "" && state.userInputs[state.currentSlot] !== key) state.hasUsedBack = true;
            state.userInputs[state.currentSlot] = key;
            if (state.currentSlot === 3) { render(); checkAnswer(true); return; } else { state.currentSlot++; }
          }
        }
      }
      render();
    }

    // (其餘核心邏輯保持不變，略作縮減以符合長度)
    function handleStart(e) { 
      if(e) { e.preventDefault(); e.stopPropagation(); } 
      state.mode = 'play'; 
      state.currentSlot = 0; 
      nextProblem(); 
      if (timer) clearInterval(timer); 
      timer = setInterval(() => { 
        state.timeLeft--; 
        if (state.timeLeft <= 0) {
            endGame(); 
        } else { 
            const bar = document.getElementById('timer-bar'); 
            if(bar) bar.style.width = (state.timeLeft/TOTAL_TIME*100)+'%'; 
            // 這裡不需要每次都 render()，節省效能，只需更新進度條
        } 
      }, 1000); 
    }
    function nextProblem() { const a = Math.floor(Math.random()*19)-9, b = Math.floor(Math.random()*19)-9; const B = a+b, C = a*b; let bT = B===0?"":(B===1?"+ x":(B===-1?"- x":(B>0?"+ "+B+"x":"- "+Math.abs(B)+"x"))); let cT = C===0?"":(C>0?"+ "+C:"- "+Math.abs(C)); state.problem = { display: `x² ${bT} ${cT}`, ansA: a, ansB: b, start: Date.now() }; state.userInputs = ["", "", "", ""]; state.currentSlot = 0; state.isAnswerCorrect = false; state.hasUsedBack = false; render(); }
    function checkAnswer(f) { const v1 = parseInt((state.userInputs[0]||"+")+(state.userInputs[1]||"0")), v2 = parseInt((state.userInputs[2]||"+")+(state.userInputs[3]||"0")); const t1 = state.problem.ansA, t2 = state.problem.ansB; if (((v1===t1 && v2===t2) || (v1===t2 && v2===t1)) && f) handleCorrect(v1, v2); }
    function handleCorrect(v1,v2) { state.isAnswerCorrect = true; const ts = (Date.now()-state.problem.start)/1000; if (state.hasUsedBack) state.combo = 0; else state.combo++; if (state.combo>state.maxCombo) state.maxCombo = state.combo; let earn = state.combo > 0 ? (1+(0.1*(state.combo-1))) : 1; state.score += earn; render(); fetch(`${SCRIPT_URL}?action=save&type=Factor&studentName=${encodeURIComponent(state.name)}&problem=${encodeURIComponent(state.problem.display)}&correctAnswer=${state.problem.ansA},${state.problem.ansB}&userAnswer=${v1},${v2}&isCorrect=true&timeSpent=${ts}&score=${earn.toFixed(4)}&combo=${state.combo}`, { mode: 'no-cors' }); setTimeout(nextProblem, 300); }
    function endGame() { clearInterval(timer); state.mode = 'end'; render(); fetch(`${SCRIPT_URL}?action=saveSummary&type=Factor&studentName=${encodeURIComponent(state.name)}&score=${state.score.toFixed(2)}&maxCombo=${state.maxCombo}`, { mode: 'no-cors' }); }
    window.onkeydown = (e) => { if (state.mode === 'play') { if (e.key >= '0' && e.key <= '9' || e.key === '+' || e.key === '-') pressKey(e.key); else if (e.key === 'Backspace' || e.key === 'ArrowLeft') { e.preventDefault(); pressKey('back'); } else if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowRight') { e.preventDefault(); pressKey('next'); } } };

    window.onload = () => {
      handleStart();
    };
  </script>
</body>
</html>
