<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>廣義角實驗室 - Math Lab</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="js/session-manager.js?v=20260118"></script>
  <script src="js/ui-header.js?v=20260118"></script>
  <script src="js/sync-protocol.js?v=20260118"></script>
  <script src="js/scoring-engine.js?v=20260118"></script>

  <style>
    :root { --fluid-text: clamp(2rem, 10vw, 4rem); }
    body { background-color: #f8fafc; overflow: hidden; touch-action: none; }
    canvas { touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
    .correct-flash { animation: flash 0.4s ease-out; }
    @keyframes flash { 0% { background-color: transparent; } 50% { background-color: #dbeafe; } 100% { background-color: transparent; } }
  </style>
</head>
<body class="text-slate-800 font-sans">
  <div id="app"></div>

  <script>
    // --- 1. 全域配置與狀態 ---
    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbz5SPY0XNjPWaRAgSmSZx1cSgTTeuACaT17Lx96Oy0TkALO0mgOKA-mr3KuUtFCNVir2Q/exec'; 
    const TOTAL_TIME = 120;
    const specialAngles = [0, 30, 45, 60, 90, 120, 135, 150, 180, 210, 225, 240, 270, 300, 315, 330];
    
    let timer = null;
    let state = {
      mode: 'play',
      gameType: 'directedAngle',
      sessionId: '', // 啟動時填充
      name: '',      // 啟動時填充
      targetAngle: null,
      lastAngle: null,
      userAngle: null,
      isDown: false,
      startTime: 0,
      timeLeft: TOTAL_TIME,
      score: 0,
      combo: 0,
      maxCombo: 0,
      // 引擎所需標準屬性
      totalSolved: 0,
      totalPerfect: 0,
      hasModified: false,
      attempts: 1,
      stats: { totalTime: 0, perfectTime: 0, correctedTime: 0 },
      isCorrectFlash: false
    };

    // --- 2. 核心渲染邏輯 (盒子 -> 模組 -> 手工) ---
    function render() {
      const app = document.getElementById('app');
      if (!app) return;

      // 結束畫面
      if (state.mode === 'end') {
        const accuracy = state.totalSolved > 0 ? ((state.totalPerfect / state.totalSolved) * 100).toFixed(1) : "0.0";
        app.innerHTML = /* html */ `
          <div class="min-h-screen flex items-center justify-center p-4 bg-slate-100">
            <div class="bg-white p-8 rounded-[2.5rem] shadow-2xl w-full max-w-md text-center border-b-[12px] border-blue-600">
              <h2 class="text-xl font-black mb-1 italic uppercase text-slate-400">Challenge Finished</h2>
              <div class="text-lg font-bold text-slate-600 mb-4">${state.name}</div>
              <div class="text-6xl font-black text-blue-600 mb-8 leading-tight">${state.score.toFixed(2)}</div>
              <div class="space-y-3 mb-10 text-left bg-slate-50 p-6 rounded-3xl border border-slate-100">
                <div class="flex justify-between items-center"><span class="text-slate-500 font-bold">總答對數</span><span class="text-slate-800 font-black text-xl">${state.totalSolved}</span></div>
                <div class="flex justify-between items-center"><span class="text-slate-500 font-bold">最高連擊</span><span class="text-orange-500 font-black text-xl">${state.maxCombo}</span></div>
                <div class="flex justify-between items-center"><span class="text-slate-500 font-bold">一次到位率</span><span class="text-slate-800 font-black text-xl">${accuracy}%</span></div>
              </div>
              <button onclick="location.reload()" class="w-full bg-blue-600 text-white py-4 rounded-2xl font-black shadow-lg text-xl active:scale-95 transition-all">再次挑戰</button>
            </div>
          </div>`;
        return;
      }

      // 遊戲畫面骨架 (盒子先行)
      app.innerHTML = /* html */ `
        <div class="min-h-screen p-4 flex flex-col items-center max-w-6xl mx-auto ${state.isCorrectFlash ? 'correct-flash' : ''}">
          <div class="w-full text-center">
            <div id="header-area"></div> <div class="mt-8 mb-2 text-slate-400 font-bold tracking-widest uppercase text-sm">Target Angle</div>
            <div class="font-black text-slate-800 mb-6 italic" style="font-size: var(--fluid-text)">${state.targetAngle}°</div>
            
            <div class="relative inline-block shadow-2xl rounded-full bg-white p-2 border-4 border-slate-50">
              <canvas id="angleCanvas" width="360" height="360"></canvas>
            </div>
          </div>
        </div>`;

      // 填入外部模組 (Header)
      if (typeof UIHeader !== 'undefined') {
        UIHeader.render('header-area', state);
      }

      // 最後繪製手工 Canvas
      drawCircle();
    }

    // --- 3. 繪圖與物理邏輯 ---
    function drawCircle() {
      const canvas = document.getElementById('angleCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const cx = 180, cy = 180, r = 175;

      ctx.clearRect(0, 0, 360, 360);
      
      // 座標軸
      ctx.setLineDash([]); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, 360); ctx.moveTo(0, cy); ctx.lineTo(360, cy); ctx.stroke();

      // 特殊角提示
      ctx.setLineDash([4, 6]); ctx.strokeStyle = '#cbd5e1';
      specialAngles.forEach(deg => {
        const rad = deg * Math.PI / 180;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + r * Math.cos(rad), cy - r * Math.sin(rad)); ctx.stroke();
      });

      // 使用者指針
      if (state.userAngle !== null) {
        const userRad = state.userAngle * Math.PI / 180;
        ctx.setLineDash([]); ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(59, 130, 246, 0.4)';
        ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 8; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + r * Math.cos(userRad), cy - r * Math.sin(userRad)); ctx.stroke();
      }
      
      // 原點
      ctx.fillStyle = '#1e40af'; ctx.shadowBlur = 0;
      ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2); ctx.fill();
    }

    function snapAngle(x, y) {
      const dx = x - 180, dy = 180 - y;
      let deg = Math.atan2(dy, dx) * 180 / Math.PI;
      if (deg < 0) deg += 360;
      return specialAngles.reduce((prev, curr) => {
        const getDist = (a, b) => {
          const d = Math.abs(a - b) % 360;
          return d > 180 ? 360 - d : d;
        };
        return getDist(curr, deg) < getDist(prev, deg) ? curr : prev;
      });
    }

    // --- 4. 遊戲流程控制 ---
    function handleInput(e) {
      if (state.mode !== 'play') return;
      const canvas = document.getElementById('angleCanvas');
      const rect = canvas.getBoundingClientRect();
      const t = e.touches ? e.touches[0] : e;
      state.userAngle = snapAngle(t.clientX - rect.left, t.clientY - rect.top);
      drawCircle();
    }

    function checkAnswer() {
      if (state.isCorrectFlash || state.userAngle === null) return;
      
      const isCorrect = (state.userAngle - state.targetAngle) % 360 === 0;
      
      if (isCorrect) {
        state.isCorrectFlash = true;
        const ts = (Date.now() - state.startTime) / 1000;
        
        // 評分引擎處理
        const result = ScoringEngine.processCorrect(state, ts);
        render();

        // 資料同步
        const p = {
          problem: state.targetAngle + "°",
          ans: state.targetAngle,
          userAns: state.userAngle,
          status: true,
          ts: ts,
          earn: result.earn,
          keyLog: "" 
        };
        SyncProtocol.saveLog(SCRIPT_URL, state, p);
        
        setTimeout(() => {
          state.isCorrectFlash = false;
          nextProblem();
        }, 300);
      } else {
        state.combo = 0;
        render();
      }
    }

    function nextProblem() {
      let newTarget;
      do {
        newTarget = specialAngles[Math.floor(Math.random() * specialAngles.length)];
      } while (newTarget === state.lastAngle);
      
      state.targetAngle = newTarget;
      state.lastAngle = newTarget;
      state.startTime = Date.now();
      state.userAngle = null;
      state.attempts = 1; // 重置嘗試次數給引擎判斷 Perfect
      render();
    }

    function startTimer() {
      if (timer) clearInterval(timer);
      timer = setInterval(() => {
        state.timeLeft--;
        if (state.timeLeft <= 0) {
          clearInterval(timer);
          state.mode = 'end';
          SyncProtocol.saveSummary(SCRIPT_URL, state);
        }
        render();
      }, 1000);
    }

    // --- 5. 事件綁定與啟動 ---
    function initEventListeners() {
      const onStart = (e) => { if(state.mode === 'play') { state.isDown = true; handleInput(e); } };
      const onMove = (e) => { if(state.isDown) { e.preventDefault(); handleInput(e); } };
      const onEnd = (e) => { 
        if (state.isDown) { 
          if (e.changedTouches) handleInput(e.changedTouches[0]);
          else if (e.clientX !== undefined) handleInput(e);
          state.isDown = false; 
          checkAnswer(); 
        } 
      };

      window.addEventListener('mousedown', onStart);
      window.addEventListener('touchstart', onStart, {passive: false});
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove', onMove, {passive: false});
      window.addEventListener('mouseup', onEnd);
      window.addEventListener('touchend', onEnd);
    }

    // 真正的啟動程序
    window.onload = () => {
      UIHeader.initTheme();     // 初始化主題
      state.name = SessionManager.getName();
      state.sessionId = SessionManager.getSessionId();
      SessionManager.refresh(); // 刷新 ID
      
      initEventListeners();
      nextProblem();
      startTimer();
    };
  </script>
</body>
</html>
