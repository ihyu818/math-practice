<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>三角比實驗室 - Math Lab</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="js/session-manager.js?v=20260119"></script>
  <script src="js/scoring-engine.js?v=20260119"></script>
  <script src="js/ui-header.js?v=20260119"></script>
  <script src="js/ui-summary.js?v=20260119"></script>
  <script src="js/sync-protocol.js?v=20260119"></script>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital@1&display=swap" rel="stylesheet">
  <style>
    :root { --fluid-text: clamp(1.5rem, 5vw, 2.5rem); }
    body { background-color: #f8fafc; overflow-x: hidden; touch-action: manipulation; }
    .serif-math { font-family: 'Playfair Display', serif; font-style: italic; }
    .fraction-line { height: 3px; width: 100%; background-color: #1e293b; margin: 4px 0; }
    .input-box { transition: all 0.2s; min-width: 80px; height: 50px; cursor: pointer; }
    .input-active { background-color: #f0fdf4; border-bottom: 4px solid #16a34a !important; }
    .key-btn { height: 60px; display: flex; align-items: center; justify-content: center; border-radius: 12px; font-weight: bold; font-size: 1.4rem; cursor: pointer; user-select: none; }
    .key-btn:active { transform: scale(0.95); opacity: 0.8; }
  </style>
</head>
<body class="text-slate-800 font-sans">
  <div id="app"></div>

  <script>
    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbz5SPY0XNjPWaRAgSmSZx1cSgTTeuACaT17Lx96Oy0TkALO0mgOKA-mr3KuUtFCNVir2Q/exec';
    const pythagoreanTriples = [[3, 4, 5], [5, 12, 13], [7, 24, 25], [8, 15, 17], [9, 40, 41]];

    let state = {
      mode: 'play',
      sessionId: SessionManager.getSessionId(),
      name: SessionManager.getName(),
      gameType: 'trigRatio',
      problem: null,
      num: "", den: "", activeField: 'num',
      score: 0, combo: 0, maxCombo: 0, timeLeft: 120,
      totalSolved: 0, startTime: 0, isCorrectFlash: false
    };

    function nextProblem() {
      const base = pythagoreanTriples[Math.floor(Math.random() * pythagoreanTriples.length)];
      let [x, y, r] = Math.random() > 0.5 ? [base[0], base[1], base[2]] : [base[1], base[0], base[2]];
      const scale = Math.random() > 0.8 ? 2 : 1;
      x *= scale; y *= scale; r *= scale;

      const quad = Math.floor(Math.random() * 4) + 1;
      if (quad === 2) x = -x;
      else if (quad === 3) { x = -x; y = -y; }
      else if (quad === 4) y = -y;

      const types = ['sin', 'cos', 'tan'];
      const type = types[Math.floor(Math.random() * types.length)];

      state.problem = { x, y, r, type, target: type === 'sin' ? y/r : (type === 'cos' ? x/r : y/x) };
      state.num = ""; state.den = ""; state.activeField = 'num';
      state.startTime = Date.now();
      render();
    }

    function render() {
      const app = document.getElementById('app');
      if (!app) return;
      if (state.mode === 'end') { app.innerHTML = ""; UISummary.render('app', state); return; }

      // 佈局放寬至 max-w-4xl
      app.innerHTML = `
        <div class="min-h-screen p-4 flex flex-col items-center max-w-4xl mx-auto ${state.isCorrectFlash ? 'bg-green-100' : ''} transition-colors duration-300">
          <div id="header-area" class="w-full"></div>
          
          <div class="mt-6 text-center">
            <div class="text-xl text-slate-500 font-bold serif-math">
              P( <span class="text-slate-900 text-2xl">${state.problem.x}, ${state.problem.y}</span> ) 為終邊上一點
            </div>
          </div>

          <div class="flex flex-col md:flex-row items-center justify-center gap-12 my-8 w-full">
            <canvas id="trigCanvas" width="400" height="400" class="bg-white rounded-2xl shadow-lg border border-slate-100"></canvas>
            
            <div class="flex flex-col items-center">
                <div class="text-4xl font-black mb-8 serif-math text-green-700 underline underline-offset-8">${state.problem.type} θ = ?</div>
                
                <div class="flex items-center space-x-6 mb-10">
                    <span class="text-5xl serif-math">${state.problem.type} θ =</span>
                    <div class="flex flex-col items-center w-32">
                        <div id="box-num" class="input-box w-full text-center text-3xl font-bold flex items-center justify-center rounded-t-lg ${state.activeField === 'num' ? 'input-active shadow-md' : 'bg-slate-50'}" onclick="state.activeField='num';render();">${state.num}</div>
                        <div class="fraction-line"></div>
                        <div id="box-den" class="input-box w-full text-center text-3xl font-bold flex items-center justify-center rounded-b-lg ${state.activeField === 'den' ? 'input-active shadow-md' : 'bg-slate-50'}" onclick="state.activeField='den';render();">${state.den}</div>
                    </div>
                </div>

                <div class="grid grid-cols-4 gap-3 w-full max-w-md">
                    ${[7,8,9,'DEL',4,5,6,'/',1,2,3,'←',0,'-','→','Enter'].map(k => `
                    <div class="key-btn ${!isNaN(k) ? 'bg-white shadow-sm border border-slate-200' : (k==='Enter'?'bg-blue-600 text-white shadow-lg':'bg-slate-200')}" onclick="handleKey('${k}')">${k}</div>
                    `).join('')}
                </div>
            </div>
          </div>
        </div>`;
      
      UIHeader.render('header-area', state);
      drawDiagram();
    }

    function drawDiagram() {
      const canvas = document.getElementById('trigCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const cx = 200, cy = 200, r_visual = 150;
      const { x, y, r } = state.problem;
      const px = cx + (x / r) * r_visual;
      const py = cy - (y / r) * r_visual;
    
      ctx.clearRect(0, 0, 400, 400);
      
      // 1. 繪製坐標軸
      ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(cx, 20); ctx.lineTo(cx, 380); ctx.moveTo(20, cy); ctx.lineTo(380, cy); ctx.stroke();
    
      // 2. 繪製參考三角形 (垂線)
      ctx.setLineDash([6, 4]); ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, cy); ctx.stroke();
    
      // 3. 繪製弧形箭頭 (theta) - 核心修改處
      let angleRad = Math.atan2(-y, x); // Canvas y軸向下，故帶負號取得數學座標系的弧度
      if (angleRad > 0) angleRad -= Math.PI * 2; // 強制取得逆時針方向的角度值 (負值)
    
      const arcRadius = 45;
      ctx.setLineDash([]); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2.5;
      ctx.beginPath();
      // 從 0 度 (3點鐘方向) 開始，逆時針繪製到目標角度
      ctx.arc(cx, cy, arcRadius, 0, angleRad, true); 
      ctx.stroke();
    
      // 4. 繪製箭頭末端
      const arrowSize = 8;
      const headAngle = angleRad; 
      // 計算箭頭兩側的點
      ctx.beginPath();
      ctx.moveTo(cx + arcRadius * Math.cos(headAngle), cy + arcRadius * Math.sin(headAngle));
      ctx.lineTo(cx + (arcRadius - arrowSize) * Math.cos(headAngle + 0.3), cy + (arcRadius - arrowSize) * Math.sin(headAngle + 0.3));
      ctx.stroke();
    
      // 5. 標記 θ 字樣 - 根據角度中點放置
      const labelRadius = arcRadius + 25;
      const midAngle = angleRad / 2;
      ctx.fillStyle = '#1d4ed8'; ctx.font = 'bold 22px Playfair Display';
      ctx.fillText('θ', cx + labelRadius * Math.cos(midAngle) - 5, cy + labelRadius * Math.sin(midAngle) + 8);
    
      // 6. 繪製終邊與 P 點
      ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 5; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(px, py); ctx.stroke();
      ctx.fillStyle = '#15803d'; ctx.beginPath(); ctx.arc(px, py, 7, 0, Math.PI * 2); ctx.fill();
    }
    function handleKey(k) {
      if (k === 'DEL') {
        if (state[state.activeField] === "" && state.activeField === 'den') {
            state.activeField = 'num';
        } else {
            state[state.activeField] = state[state.activeField].slice(0, -1);
        }
      } else if (k === '/' || k === '→') {
        state.activeField = 'den';
      } else if (k === '←') {
        state.activeField = 'num';
      } else if (k === '-') {
        if (!state[state.activeField].includes('-')) {
            state[state.activeField] = '-' + state[state.activeField];
        } else {
            state[state.activeField] = state[state.activeField].replace('-', '');
        }
      } else if (k === 'Enter') {
        checkAnswer();
        return; // 避免重複渲染
      } else if (!isNaN(k)) {
        state[state.activeField] += k;
      }
      render();
    }

function checkAnswer() {
      // 1. 安全檢查：確保分子分母都有輸入，且分母有效
      if (state.num === "" || state.den === "" || state.den === "0" || state.den === "-") return;

      // 2. 數值轉換與判定
      const userVal = parseFloat(state.num) / parseFloat(state.den);
      const isCorrect = Math.abs(userVal - state.problem.target) < 0.001;
      
      if (isCorrect) {
        state.isCorrectFlash = true;
        const ts = (Date.now() - state.startTime) / 1000;
        
        // 呼叫引擎處理分數 (確保這行沒報錯)
        if (typeof ScoringEngine !== 'undefined') {
          ScoringEngine.processCorrect(state, ts);
        }

        // 儲存紀錄
        SyncProtocol.saveLog(SCRIPT_URL, state, { 
          problem: `${state.problem.type}(${state.problem.x},${state.problem.y})`, 
          userAns: `${state.num}/${state.den}` 
        });

        // 3. 延遲後執行下一題並重置輸入狀態
        setTimeout(() => {
          state.isCorrectFlash = false;
          state.num = ""; // 清空分子
          state.den = ""; // 清空分母
          state.activeField = 'num'; // 游標跳回分子
          nextProblem(); // 產生新題目
        }, 500);
      } else {
        // 答錯時的處理
        state.combo = 0;
        state.isCorrectFlash = false;
        state.num = ""; 
        state.den = ""; 
        state.activeField = 'num';
        render();
      }
    }
        
    function startTimer() {
      const t = setInterval(() => {
        state.timeLeft--;
        if (state.timeLeft <= 0) { 
            clearInterval(t); 
            state.mode = 'end'; 
            SyncProtocol.saveSummary(SCRIPT_URL, state); 
        }
        render();
      }, 1000);
    }

    UIHeader.initTheme(); 
    nextProblem(); 
    startTimer();
  </script>
</body>
</html>
